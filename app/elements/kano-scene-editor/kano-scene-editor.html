<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../behaviors/kano-scene-component-behavior.html">
<link rel="import" href="../behaviors/kano-editor-view-behavior.html">
<link rel="import" href="../kano-power-up-modal/kano-power-up-modal.html">
<link rel="import" href="../kano-app-challenge/kano-app-challenge.html">
<link rel="import" href="../kano-app-editor/kano-app-editor.html">
<link rel="import" href="../kano-challenge-progress/kano-challenge-progress.html">
<link rel="import" href="../kano-share-modal/kano-share-modal.html">
<dom-module id="kano-scene-editor">
  <style>
    :host {
      display: block;
      @apply(--layout-vertical);
    }
    :host kano-app-challenge {
        @apply(--layout-flex);
    }
    :host kano-app-editor {
        @apply(--layout-flex);
    }
    :host kano-challenge-progress {
        position: absolute;
        top: 20px;
        right: 20px;
    }
  </style>
  <template>
      <kano-app-challenge id="challenge"
                            steps="[[scene.steps]]"
                            on-save="saveApp"
                            on-save-to-storage="saveToStorage"
                            on-load="loadApp"
                            step="{{currentStep}}"
                            started="[[scene.started]]">
          <kano-app-editor id="editor"
                            added-parts="{{addedParts}}"
                            parts="[[computeParts(scene.*, remix)]]"
                            default-categories="[[computeCategories(scene.*, remix)]]"
                            slot="editor"
                            running="{{running}}"
                            title="[[storyName]]"
                            code="{{code}}"
                            mode="[[_computeMode(mode, remix)]]"
                            on-blockly-ready="_blocklyReady"
                            on-share="_pauseAndShare">
              <kano-challenge-progress id="challenge-progress" progress="[[progress]]" title="[[storyName]]" next-challenge="[[nextStory.id]]" on-share-app="shareApp" remix-mode="[[remix]]"></kano-challenge-progress>
          </kano-app-editor>
      </kano-app-challenge>
      <kano-power-up-modal id="challenge-completed"
                            options="[[extensions]]"
                            app-preview="[[appPreview]]"
                            story-name="[[storyName]]"
                            next-story="[[nextStory]]"
                            on-close="goToRemixChallenge"
                            on-power-up="powerUp"
                            on-share-app="shareApp"></kano-power-up-modal>
      </paper-dialog>
  </template>
</dom-module>
<script type="text/javascript">

    /* globals Polymer, Kano */

    Polymer({
        is: 'kano-scene-editor',
        behaviors: [Kano.Behaviors.EditorViewBehavior, Kano.Behaviors.SceneComponentBehavior],
        properties: {
            storyName: {
                type: String
            },
            nextStory: {
                type: String
            },
            currentStep: {
                type: Number,
                value: 0
            },
            progress: {
                type: Number,
                computed: "computeProgress(currentStep, scene)"
            },
            extensions: {
                type: Array
            },
            addedParts: {
                type: Array
            },
            remix: {
                type: Boolean,
                observer: '_remixChanged'
            }
        },
        observers: [
            'endedChanged(scene.ended)',
            '_sceneChanged(scene)',
            '_sceneStarted(scene.started)',
            '_addedPartsChanged(addedParts.splices)'
        ],
        _pauseAndShare (e) {
            this.running = false;
            this.fire('share', e.detail);
            e.preventDefault();
            e.stopPropagation();
        },
        _remixChanged (remix) {
            if (remix) {
                // Look for the previously removed blocks in the addedParts
                this.addedParts.forEach((part, i) => {
                    // Some blocks were removed, we need to add them back
                    if (part.removedBlocks) {
                        // Go through all the removed blocks and inject them back in the blocks array
                        Object.keys(part.removedBlocks).forEach(index => {
                            this.splice(`addedParts.${i}.blocks`, index, 0, part.removedBlocks[index]);
                        });
                        delete part.removedBlocks;
                    }
                });
            }
        },
        /**
         * Observes the `addedParts` array. Goes through the added splice and removes the blocks from a part if needed.
         * Stores the removed blocks in a `removedBlocks` object for future re-injection 
         */
        _addedPartsChanged (e) {
            if (!e || this.remix || !this.scene.filterBlocks) {
                return;
            }
            e.indexSplices.forEach(splice => {
                splice.object.forEach(part => {
                    Object.keys(this.scene.filterBlocks).forEach(key => {
                        if (!part.type === key) {
                            return;
                        }
                        part.blocks = part.blocks.filter((block, index) => {
                            let definition = block.block(part),
                                remove = this.scene.filterBlocks[key].indexOf(definition.id) === -1;
                            // We're about to remove the block from the part. Save it under another object to
                            // be able to inject it back later
                            if (remove) {
                                part.removedBlocks = part.removedBlocks || {};
                                part.removedBlocks[index] = block;
                            }
                            return !remove;
                        });
                    });
                });
            });
        },
        _sceneStarted (started) {
            if (started) {
                this.$['challenge-progress'].animateIn();
            }
        },
        _blocklyReady (scene) {
            this._loadVariables();
            this.async(() => {
                this._loadDefaultApp();
            });
        },
        _sceneChanged () {
            this._loadVariables();
        },
        _loadVariables () {
            let workspace = this.$.editor.getBlocklyWorkspace();
            if (this.scene && this.scene.variables && workspace) {
                this.scene.variables.forEach((v) => {
                    Blockly.Variables.addVariable(v, workspace);
                });
            }
        },
        _loadDefaultApp () {
            let editor = this.$.editor;
            if (this.scene && this.scene.defaultApp) {
                editor.load(JSON.parse(this.scene.defaultApp), Kano.MakeApps.Parts.list);
            }
        },
        endedChanged () {
            if (this.scene.ended) {
                this.$.editor.generateCover().then((image) => {
                    this.appPreview = image.src;
                    this.$['challenge-completed'].open();
                });
            }
        },
        computeProgress (currentStep, scene) {
            return (currentStep + 1) / scene.steps.length;
        },
        ready () {
            this.remix = false;
            this.code = {};

            this.debounce('saveApp', () => {
                this.editor = this.$.editor;
                this.editor.addEventListener('change', (e) => {
                    this.saveApp(e);
                });
            }, 300);
        },
        attached () {
            this.mode = Kano.MakeApps.Mode.modes[(this.scene.mode || 'normal')];
        },
        shareApp () {
            this.$.editor.share();
        },
        computeParts () {
            if (this.remix) {
                return Kano.MakeApps.Parts.list.filter((part) => {
                    return this.mode.parts.indexOf(part.type) !== -1;
                });
            } else {
                return Kano.MakeApps.Parts.list.filter(part => this.scene.parts.indexOf(part.type) !== -1);
            }
        },
        /**
         * Returns the categories that will be used in this challenge. Takes care of filtering the
         * categories and blocks that will not be used. Resets everything when the users enters remix mode
         */
        computeCategories () {
            let cats = {},
                cat;
            if (this.remix) {
                cats = Kano.MakeApps.Blockly.categories;
            } else {
                this.scene.modules.forEach(id => {
                    // Clone the object, because we might change its blocks
                    cats[id] = Object.assign({}, Kano.MakeApps.Blockly.categories[id]);
                });
                cats.events = Object.assign({}, Kano.MakeApps.Blockly.categories.events);

                // Do not filter blocks if the list is not defined
                if (this.scene.filterBlocks) {
                    // Remove the excluded blocks from the categories
                    Object.keys(this.scene.filterBlocks).forEach(catId => {
                        cat = cats[catId];
                        if (!cat) {
                            return;
                        }
                        cat.blocks = cat.blocks.filter(block => this.scene.filterBlocks[catId].indexOf(block.id) !== -1);
                    });
                }
            }

            return cats;
        },
        _computeMode () {
            let mode = this.mode;
            if (this.remix) {
                if (mode.originalBlocks) {
                    mode.blocks = mode.originalBlocks;
                    delete mode.originalBlocks;
                }
            } else if (this.scene.filterBlocks) {
                let whitelist = this.scene.filterBlocks[mode.id];
                if (whitelist) {
                    mode.originalBlocks = mode.blocks;
                    mode.blocks = mode.blocks.filter(block => {
                        let definition = block.block(mode);
                        return whitelist.indexOf(definition.id) !== -1;
                    });
                }
            }
            return mode;
        },
        saveApp (e) {
            let id = e.detail.id || 'current',
                blockIds = e.detail.blockIds,
                stepIds = e.detail.stepIds,
                app = this.$.editor.save(true, false);
            this.addToStore(id, {
                app,
                blockIds,
                stepIds
            });
        },
        saveToStorage () {
            let app = this.$.editor.save();
            localStorage.setItem('savedApp', JSON.stringify(app));
        },
        loadApp (e) {
            let id = e.detail,
                savedState,
                challenge;
            savedState = this.fromStore(id);
            challenge = this.$.challenge;
            this.$.editor.load(savedState.app, this.computeParts());
            challenge.set('stepIds', savedState.stepIds);
            challenge.set('blockIds', savedState.blockIds);
        },
        goToRemixChallenge () {
            this.remix = true;
        },
        powerUp (e) {
            let extensionId = e.detail.id;
            this.fire('extend-story', extensionId);
            e.stopPropagation();
        },
        _runningChanged () {
            if (!this.scene.started) {
                return;
            }
            Kano.Behaviors.EditorViewBehavior._runningChanged.apply(this, arguments);
        }
    });
</script>
